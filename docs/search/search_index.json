{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Martin's Tech Blog","text":"<p>Here I'll write about my studies of new technologies.</p>"},{"location":"posts/fetching-data-in-react/","title":"Fetching data in React","text":"<p>I've been developing in React for quite some time now. Usually when I needed to fetch some data, it was fine to create a <code>useEffect</code> hook, fetch it and then set it into a state using the useState hook. However, recently I've been wondering if there is a cleaner way, including error handling and retries. And of counrse there is. There is actually several. Here I'll try to learn more about the possibilities of data fetching in React</p>"},{"location":"posts/fetching-data-in-react/#the-example-app","title":"The example app","text":"<p>I'll be trying the methods on an example todo app I prepared. The app looks something like this:</p> <p></p> <p>The implementation is very trivial. It looks something like this:</p> <pre><code>function App() {\n  const [todos, setTodos] = useState&lt;Todo[]&gt;([])\n  const [newTodo, setNewTodo] = useState&lt;string&gt;(\"\")\n\n  const [isAppLoading, setAppLoading] = useState(false)\n  const [isNewLoading, setNewLoading] = useState(false)\n  const [isRemoveLoading, setRemoveLoading] = useState(false)\n  const [isRemoveAllLoading, setRemoveAllLoading] = useState(false)\n\n  const removedTodo = useRef&lt;string | null&gt;(null)\n\n  function resetInput() {\n    setNewTodo('')\n  }\n\n  async function fetchTodos() {\n    setTodos(await getTodos())\n  }\n\n  useEffect(() =&gt; {\n    (async () =&gt; {\n      setAppLoading(true)\n\n      await fetchTodos()\n\n      setAppLoading(false)\n    })()\n  }, [])\n\n  async function submitAddTodo() {\n    setNewLoading(true)\n\n    await addTodo({ id: null, content: newTodo })\n    await fetchTodos()\n\n    setNewLoading(false)\n    resetInput()\n  }\n\n  async function submitDeleteTodo(todo: Todo) {\n    setRemoveLoading(true)\n    removedTodo.current = todo.id\n\n    await deleteTodo(todo)\n    await fetchTodos()\n\n    setRemoveLoading(false)\n    removedTodo.current = null\n    resetInput()\n  }\n\n  async function submitDeleteAllTodos() {\n    setRemoveAllLoading(true)\n\n    await deleteAllTodos()\n    await fetchTodos()\n\n    setRemoveAllLoading(false)\n    resetInput()\n  }\n\n  if (isAppLoading) {\n    return &lt;div className=\"loader\"/&gt;\n  }\n\n  return (\n    &lt;&gt;...&lt;/&gt;\n  )\n}\n</code></pre> <p>I omitted the JSX markup as that's not the point of today's exercise.</p> <p>I tried to handle all the waiting for API responses in a nice UX-friendly way, but I guess you'll be the judge of that. Although that made a bit of a mess in the component's state.</p> <p>The todo service functions look something like this:</p> <pre><code>export interface Todo {\n  id: string | null;\n  content: string;\n}\n\nconst BASE_URL = import.meta.env.DEV\n  ? 'http://localhost:8080'\n  : '/'\nconst TODO_URL = `${BASE_URL}/api/todos`\n\nexport async function getTodos(): Promise&lt;Todo[]&gt; {\n  const data = await fetchAPI(TODO_URL)\n  return await data.json()\n}\n\nexport async function addTodo(newTodo: Todo): Promise&lt;Response&gt; {\n  return fetchAPI(TODO_URL, 'POST', JSON.stringify(newTodo))\n}\n\nexport function deleteTodo(todo: Todo): Promise&lt;Response&gt; {\n  return fetchAPI(TODO_URL, 'DELETE', JSON.stringify(todo))\n}\n\nexport function deleteAllTodos(): Promise&lt;Response&gt; {\n  return fetchAPI(`${TODO_URL}/all`, 'DELETE')\n}\n\ntype HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE'\n\nasync function fetchAPI(\n  url: string,\n  method: HttpMethod = 'GET',\n  body?: string\n): Promise&lt;Response&gt; {\n  return fetch(url, {\n    method,\n    headers: {\n      ...(method !== 'GET' &amp;&amp; {\n        'Content-Type': 'application/json'\n      })\n    },\n    body\n  })\n}\n\n</code></pre> <p>It's not avery clean or a robust solution, but for the sake of this exercise, I tried to avoid too much duplication even while using the built-in fetch API. Also, the error handling and retrying of requests is completely missing. Now we'll try to improve upon this with the React Query library.</p>"},{"location":"posts/fetching-data-in-react/#react-query","title":"React Query","text":"<p>WIP</p>"},{"location":"posts/styled-components-with-react/","title":"Learning Styled Components with React","text":"<p>I've never been a big fan of tinkering with CSS. It was always a struggle to try to achieve a pixel-perfect design of the app, and the process wasn't satisfying at all. In the backend, it always felt more satisfying to improve the existing architecture, or fix some issues in the logic. If I fixed some styling issues on the frontend, usually it led to an even more complicated CSS file. But that's probably mostly from lack of experience with it.</p> <p>But today I'll try to  rewrite the basic Todo app's CSS into a cleaner Styled Components solution, while preserving the current design.</p>"},{"location":"posts/styled-components-with-react/#the-example-app","title":"The example app","text":"<p>I'll be trying Styled Components with an example Todo app I prepared. The app looks something like this:</p> <p></p> <p>My main goal is to not break the app when trying to fit in the Styled Components.</p>"}]}