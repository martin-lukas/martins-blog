{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Martin's Tech Blog Here I'll write about my studies of new technologies.","title":"Home"},{"location":"#welcome-to-martins-tech-blog","text":"Here I'll write about my studies of new technologies.","title":"Welcome to Martin's Tech Blog"},{"location":"advent-of-code-2022/day-01/","text":"Day 1 - Snack carrying elves Advent of Code 2022 - Day 1 This is the first day of the Advent of Code 2022 challenges. I decided to try this challenge using Java, specifically Java 17, as I'd like to improve especially my Stream API knowledge. Today's challenges are: Find the elf with the most calories Find the top 3 elves with the most carried calories 1. Find the elf with the most calories I started by writing a simple record called Elf with two methods - static from(String) for creating an elf from a string, and totalCalories() for getting the sum of all his snacks' calories. Implementation here: record Elf ( List < Integer > calories ) { static Elf from ( String calorieString ) { List < Integer > calories = Arrays . stream ( calorieString . split ( \"\\n\" )) . map ( Integer :: parseInt ) . toList (); return new Elf ( calories ); } int totalCalories () { return calories . stream (). mapToInt ( i -> i ). sum (); } } You can notice a heavy use of Streams. I'd point out in the method totalCalories() , I use the operation mapToInt(i -> i) , which may seem a bit strange to some. Conversion from Stream<Integer> to IntStream The only purpose of this operation is to convert the Stream<Integer> object into an IntStream stream of primitives. The terminal operation sum() is available only for IntStream , because it's not useful for all objects like the other terminal operations for Stream<T> . The conversion uses the concept of \"automatic unboxing\" of the Integer object. Another way would be to use the operation mapToInt(Integer::intValue) , which would do the same, just in a more verbose way. We could also stick to Stream<Integer> only, by using reduce(Integer, BinaryOperator<Integer>) instead of sum() . That would look something like - reduce(0, (a, b) -> a + b) . The 0 is the initial value, and a is always the previous element of the stream, b is the following, and the result of the function is set into a again. That way, the stream gets \"reduced\" into a single value. This is more verbose, and less clear from just glancing at it what the goal is. The operation sum() is definitely much clearer. After this, I needed a class to easily manage the creation of many elves from a very long string. I decided to name it ElfManager . I need a method for parsing the elven string, called createElves(String) . class ElfManager { static List < Elf > createElves ( String caloriesString ) { // each elf separated by empty line return Arrays . stream ( caloriesString . split ( \"\\n\\n\" )) . map ( Elf :: from ) . toList (); } } I'm using the Elf::from method reference to create the elves from the substrings easily. Apart from that, nothing special here. Next method is the one that is going to solve the part 1 of this exercise - getElfWithMostCalories(List<Elf>) // ElfManager class static Optional < Elf > getElfWithMostCalories ( List < Elf > elves ) { return elves . stream (). max ( Elf . BY_TOTAL_CALORIES_ASC ); } For this method, I added a Comparator object into Elf to reuse the behavior of comparing based on total carried calories. Thanks to this, we can use the max() operation which finds the maximum in the stream based on this Comparator . It will then be easy to get the solution to part 1 from this method. Now comes the time to finally calculate the first solution. For that, we need to read the input text file, and then use the prepared methods to get the result. I created a helper class FileUtils to easily read the file: public class FileUtils { private static final String PREFIX = \"src/main/resources/\" ; public static String toString ( String relativePath ) { try { return Files . readString ( Paths . get ( PREFIX + relativePath )); } catch ( IOException ex ) { throw new RuntimeException ( ex ); } } } Let's get the result with this code: String elvenString = FileUtils . toString ( \"day01/elf-calories.txt\" ); List < Elf > elves = ElfManager . createElves ( elvenString ); int maxCalories = ElfManager . getElfWithMostCalories ( elves ) . map ( Elf :: totalCalories ) . orElse ( 0 ); System . out . println ( maxCalories ); This code prints out the correct answer. 2. Find the top 3 elves with the most carried calories The next part will build up on the methods I've already created, or at least on similar concepts. For getting this solution, I need a new method - getTopNElves(List<Elf>, int) : // ElfManager class static List < Elf > getTopNElves ( List < Elf > elves , int n ) { return elves . stream () . sorted ( Elf . BY_TOTAL_CALORIES_ASC . reversed ()) . limit ( n ) . toList (); } This method will sort the list of provided elves by the comparator that I'm reusing from the 1st part. However, it needs to be reversed, in order to correctly use the limit(int) operation. This operation takes the top n stream items, so in this case the list has to be sorted in a descending order by the total calories. After we get the top 3 elves, we should sum up all of their carried calories - new method sumElfCalories(List<Elf>) : static int sumElfCalories ( List < Elf > elves ) { return elves . stream () . map ( Elf :: totalCalories ) . mapToInt ( i -> i ) . sum (); } Now I have all the necessary pieces to glue together the code for calculation this part's solution: String elvenString = FileUtils . toString ( \"day01/elf-calories.txt\" ); List < Elf > elves = ElfManager . createElves ( elvenString ); List < Elf > top3Elves = ElfManager . getTopNElves ( elves , 3 ); int sumOfCalories = ElfManager . sumElfCalories ( top3Elves ); System . out . println ( sumOfCalories ); This gives the correct solution as well. And it's pretty readable too, at least in my opinion. So there we have it, a bit verbose solution to a pretty simple programming problem. But I feel like I've created a bit of a framework for dealing with the other exercises on the following days.","title":"Day 1 - Counting Calories"},{"location":"advent-of-code-2022/day-01/#day-1-snack-carrying-elves","text":"Advent of Code 2022 - Day 1 This is the first day of the Advent of Code 2022 challenges. I decided to try this challenge using Java, specifically Java 17, as I'd like to improve especially my Stream API knowledge. Today's challenges are: Find the elf with the most calories Find the top 3 elves with the most carried calories","title":"Day 1 - Snack carrying elves"},{"location":"advent-of-code-2022/day-01/#1-find-the-elf-with-the-most-calories","text":"I started by writing a simple record called Elf with two methods - static from(String) for creating an elf from a string, and totalCalories() for getting the sum of all his snacks' calories. Implementation here: record Elf ( List < Integer > calories ) { static Elf from ( String calorieString ) { List < Integer > calories = Arrays . stream ( calorieString . split ( \"\\n\" )) . map ( Integer :: parseInt ) . toList (); return new Elf ( calories ); } int totalCalories () { return calories . stream (). mapToInt ( i -> i ). sum (); } } You can notice a heavy use of Streams. I'd point out in the method totalCalories() , I use the operation mapToInt(i -> i) , which may seem a bit strange to some.","title":"1. Find the elf with the most calories"},{"location":"advent-of-code-2022/day-01/#conversion-from-streaminteger-to-intstream","text":"The only purpose of this operation is to convert the Stream<Integer> object into an IntStream stream of primitives. The terminal operation sum() is available only for IntStream , because it's not useful for all objects like the other terminal operations for Stream<T> . The conversion uses the concept of \"automatic unboxing\" of the Integer object. Another way would be to use the operation mapToInt(Integer::intValue) , which would do the same, just in a more verbose way. We could also stick to Stream<Integer> only, by using reduce(Integer, BinaryOperator<Integer>) instead of sum() . That would look something like - reduce(0, (a, b) -> a + b) . The 0 is the initial value, and a is always the previous element of the stream, b is the following, and the result of the function is set into a again. That way, the stream gets \"reduced\" into a single value. This is more verbose, and less clear from just glancing at it what the goal is. The operation sum() is definitely much clearer. After this, I needed a class to easily manage the creation of many elves from a very long string. I decided to name it ElfManager . I need a method for parsing the elven string, called createElves(String) . class ElfManager { static List < Elf > createElves ( String caloriesString ) { // each elf separated by empty line return Arrays . stream ( caloriesString . split ( \"\\n\\n\" )) . map ( Elf :: from ) . toList (); } } I'm using the Elf::from method reference to create the elves from the substrings easily. Apart from that, nothing special here. Next method is the one that is going to solve the part 1 of this exercise - getElfWithMostCalories(List<Elf>) // ElfManager class static Optional < Elf > getElfWithMostCalories ( List < Elf > elves ) { return elves . stream (). max ( Elf . BY_TOTAL_CALORIES_ASC ); } For this method, I added a Comparator object into Elf to reuse the behavior of comparing based on total carried calories. Thanks to this, we can use the max() operation which finds the maximum in the stream based on this Comparator . It will then be easy to get the solution to part 1 from this method. Now comes the time to finally calculate the first solution. For that, we need to read the input text file, and then use the prepared methods to get the result. I created a helper class FileUtils to easily read the file: public class FileUtils { private static final String PREFIX = \"src/main/resources/\" ; public static String toString ( String relativePath ) { try { return Files . readString ( Paths . get ( PREFIX + relativePath )); } catch ( IOException ex ) { throw new RuntimeException ( ex ); } } } Let's get the result with this code: String elvenString = FileUtils . toString ( \"day01/elf-calories.txt\" ); List < Elf > elves = ElfManager . createElves ( elvenString ); int maxCalories = ElfManager . getElfWithMostCalories ( elves ) . map ( Elf :: totalCalories ) . orElse ( 0 ); System . out . println ( maxCalories ); This code prints out the correct answer.","title":"Conversion from Stream&lt;Integer&gt; to IntStream"},{"location":"advent-of-code-2022/day-01/#2-find-the-top-3-elves-with-the-most-carried-calories","text":"The next part will build up on the methods I've already created, or at least on similar concepts. For getting this solution, I need a new method - getTopNElves(List<Elf>, int) : // ElfManager class static List < Elf > getTopNElves ( List < Elf > elves , int n ) { return elves . stream () . sorted ( Elf . BY_TOTAL_CALORIES_ASC . reversed ()) . limit ( n ) . toList (); } This method will sort the list of provided elves by the comparator that I'm reusing from the 1st part. However, it needs to be reversed, in order to correctly use the limit(int) operation. This operation takes the top n stream items, so in this case the list has to be sorted in a descending order by the total calories. After we get the top 3 elves, we should sum up all of their carried calories - new method sumElfCalories(List<Elf>) : static int sumElfCalories ( List < Elf > elves ) { return elves . stream () . map ( Elf :: totalCalories ) . mapToInt ( i -> i ) . sum (); } Now I have all the necessary pieces to glue together the code for calculation this part's solution: String elvenString = FileUtils . toString ( \"day01/elf-calories.txt\" ); List < Elf > elves = ElfManager . createElves ( elvenString ); List < Elf > top3Elves = ElfManager . getTopNElves ( elves , 3 ); int sumOfCalories = ElfManager . sumElfCalories ( top3Elves ); System . out . println ( sumOfCalories ); This gives the correct solution as well. And it's pretty readable too, at least in my opinion. So there we have it, a bit verbose solution to a pretty simple programming problem. But I feel like I've created a bit of a framework for dealing with the other exercises on the following days.","title":"2. Find the top 3 elves with the most carried calories"},{"location":"posts/fetching-data-in-react/","text":"Fetching data in React I've been developing in React for quite some time now. Usually when I needed to fetch some data, it was fine to create a useEffect hook, fetch it and then set it into a state using the useState hook. However, recently I've been wondering if there is a cleaner way, including error handling and retries. And of counrse there is. There is actually several. Here I'll try to learn more about the possibilities of data fetching in React The example app I'll be trying the methods on an example todo app I prepared. The app looks something like this: The implementation is very trivial. It looks something like this: function App() { const [todos, setTodos] = useState<Todo[]>([]) const [newTodo, setNewTodo] = useState<string>(\"\") const [isAppLoading, setAppLoading] = useState(false) const [isNewLoading, setNewLoading] = useState(false) const [isRemoveLoading, setRemoveLoading] = useState(false) const [isRemoveAllLoading, setRemoveAllLoading] = useState(false) const removedTodo = useRef<string | null>(null) function resetInput() { setNewTodo('') } async function fetchTodos() { setTodos(await getTodos()) } useEffect(() => { (async () => { setAppLoading(true) await fetchTodos() setAppLoading(false) })() }, []) async function submitAddTodo() { setNewLoading(true) await addTodo({ id: null, content: newTodo }) await fetchTodos() setNewLoading(false) resetInput() } async function submitDeleteTodo(todo: Todo) { setRemoveLoading(true) removedTodo.current = todo.id await deleteTodo(todo) await fetchTodos() setRemoveLoading(false) removedTodo.current = null resetInput() } async function submitDeleteAllTodos() { setRemoveAllLoading(true) await deleteAllTodos() await fetchTodos() setRemoveAllLoading(false) resetInput() } if (isAppLoading) { return <div className=\"loader\"/> } return ( <>...</> ) } I omitted the JSX markup as that's not the point of today's exercise. I tried to handle all the waiting for API responses in a nice UX-friendly way, but I guess you'll be the judge of that. Although that made a bit of a mess in the component's state. The todo service functions look something like this: export interface Todo { id : string | null ; content : string ; } const BASE_URL = import . meta . env . DEV ? 'http://localhost:8080' : '/' const TODO_URL = ` ${ BASE_URL } /api/todos` export async function getTodos () : Promise < Todo [] > { const data = await fetchAPI ( TODO_URL ) return await data . json () } export async function addTodo ( newTodo : Todo ) : Promise < Response > { return fetchAPI ( TODO_URL , 'POST' , JSON . stringify ( newTodo )) } export function deleteTodo ( todo : Todo ) : Promise < Response > { return fetchAPI ( TODO_URL , 'DELETE' , JSON . stringify ( todo )) } export function deleteAllTodos () : Promise < Response > { return fetchAPI ( ` ${ TODO_URL } /all` , 'DELETE' ) } type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' async function fetchAPI ( url : string , method : HttpMethod = 'GET' , body? : string ) : Promise < Response > { return fetch ( url , { method , headers : { ...( method !== 'GET' && { 'Content-Type' : 'application/json' }) }, body }) } It's not avery clean or a robust solution, but for the sake of this exercise, I tried to avoid too much duplication even while using the built-in fetch API. Also, the error handling and retrying of requests is completely missing. Now we'll try to improve upon this with the React Query library. React Query WIP","title":"Fetching data in React"},{"location":"posts/fetching-data-in-react/#fetching-data-in-react","text":"I've been developing in React for quite some time now. Usually when I needed to fetch some data, it was fine to create a useEffect hook, fetch it and then set it into a state using the useState hook. However, recently I've been wondering if there is a cleaner way, including error handling and retries. And of counrse there is. There is actually several. Here I'll try to learn more about the possibilities of data fetching in React","title":"Fetching data in React"},{"location":"posts/fetching-data-in-react/#the-example-app","text":"I'll be trying the methods on an example todo app I prepared. The app looks something like this: The implementation is very trivial. It looks something like this: function App() { const [todos, setTodos] = useState<Todo[]>([]) const [newTodo, setNewTodo] = useState<string>(\"\") const [isAppLoading, setAppLoading] = useState(false) const [isNewLoading, setNewLoading] = useState(false) const [isRemoveLoading, setRemoveLoading] = useState(false) const [isRemoveAllLoading, setRemoveAllLoading] = useState(false) const removedTodo = useRef<string | null>(null) function resetInput() { setNewTodo('') } async function fetchTodos() { setTodos(await getTodos()) } useEffect(() => { (async () => { setAppLoading(true) await fetchTodos() setAppLoading(false) })() }, []) async function submitAddTodo() { setNewLoading(true) await addTodo({ id: null, content: newTodo }) await fetchTodos() setNewLoading(false) resetInput() } async function submitDeleteTodo(todo: Todo) { setRemoveLoading(true) removedTodo.current = todo.id await deleteTodo(todo) await fetchTodos() setRemoveLoading(false) removedTodo.current = null resetInput() } async function submitDeleteAllTodos() { setRemoveAllLoading(true) await deleteAllTodos() await fetchTodos() setRemoveAllLoading(false) resetInput() } if (isAppLoading) { return <div className=\"loader\"/> } return ( <>...</> ) } I omitted the JSX markup as that's not the point of today's exercise. I tried to handle all the waiting for API responses in a nice UX-friendly way, but I guess you'll be the judge of that. Although that made a bit of a mess in the component's state. The todo service functions look something like this: export interface Todo { id : string | null ; content : string ; } const BASE_URL = import . meta . env . DEV ? 'http://localhost:8080' : '/' const TODO_URL = ` ${ BASE_URL } /api/todos` export async function getTodos () : Promise < Todo [] > { const data = await fetchAPI ( TODO_URL ) return await data . json () } export async function addTodo ( newTodo : Todo ) : Promise < Response > { return fetchAPI ( TODO_URL , 'POST' , JSON . stringify ( newTodo )) } export function deleteTodo ( todo : Todo ) : Promise < Response > { return fetchAPI ( TODO_URL , 'DELETE' , JSON . stringify ( todo )) } export function deleteAllTodos () : Promise < Response > { return fetchAPI ( ` ${ TODO_URL } /all` , 'DELETE' ) } type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' async function fetchAPI ( url : string , method : HttpMethod = 'GET' , body? : string ) : Promise < Response > { return fetch ( url , { method , headers : { ...( method !== 'GET' && { 'Content-Type' : 'application/json' }) }, body }) } It's not avery clean or a robust solution, but for the sake of this exercise, I tried to avoid too much duplication even while using the built-in fetch API. Also, the error handling and retrying of requests is completely missing. Now we'll try to improve upon this with the React Query library.","title":"The example app"},{"location":"posts/fetching-data-in-react/#react-query","text":"WIP","title":"React Query"},{"location":"posts/styled-components-with-react/","text":"Learning Styled Components with React I've never been a big fan of tinkering with CSS. It was always a struggle to try to achieve a pixel-perfect design of the app, and the process wasn't satisfying at all. In the backend, it always felt more satisfying to improve the existing architecture, or fix some issues in the logic. If I fixed some styling issues on the frontend, usually it led to an even more complicated CSS file. But that's probably mostly from lack of experience with it. But today I'll try to rewrite the basic Todo app's CSS into a cleaner Styled Components solution, while preserving the current design. The example app I'll be trying Styled Components with an example Todo app I prepared. The app looks something like this: My main goal is to not break the app when trying to fit in the Styled Components.","title":"Styled Components with React"},{"location":"posts/styled-components-with-react/#learning-styled-components-with-react","text":"I've never been a big fan of tinkering with CSS. It was always a struggle to try to achieve a pixel-perfect design of the app, and the process wasn't satisfying at all. In the backend, it always felt more satisfying to improve the existing architecture, or fix some issues in the logic. If I fixed some styling issues on the frontend, usually it led to an even more complicated CSS file. But that's probably mostly from lack of experience with it. But today I'll try to rewrite the basic Todo app's CSS into a cleaner Styled Components solution, while preserving the current design.","title":"Learning Styled Components with React"},{"location":"posts/styled-components-with-react/#the-example-app","text":"I'll be trying Styled Components with an example Todo app I prepared. The app looks something like this: My main goal is to not break the app when trying to fit in the Styled Components.","title":"The example app"}]}