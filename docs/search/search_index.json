{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Martin's Tech Blog Here I'll write about my journey through studying various new technologies. Currently I'm interested in: Rust (and how to write memory-safe code) containerization (learning Docker) cloud deployment (some AWS services) React libraries (Next.js, React Query, Styled Components) I'd like to share my progress in all these, and write down my wins and struggles in them.","title":"Home"},{"location":"#welcome-to-martins-tech-blog","text":"Here I'll write about my journey through studying various new technologies. Currently I'm interested in: Rust (and how to write memory-safe code) containerization (learning Docker) cloud deployment (some AWS services) React libraries (Next.js, React Query, Styled Components) I'd like to share my progress in all these, and write down my wins and struggles in them.","title":"Welcome to Martin's Tech Blog"},{"location":"frontend/react-query/","text":"React Query - Effective Data Fetching in React I've been developing in React for quite some time now. Usually when I needed to fetch some data, it was fine to create a useEffect hook, fetch it and then set it into a state using the useState hook. However, recently I've been wondering if there is a cleaner way, including error handling and retries. And of course there is. There is actually several. Here I'll try to learn more about the possibilities of data fetching in React The example app I'll be trying the methods on an example todo app I prepared. The app looks something like this: The implementation is very trivial: function App() { const [todos, setTodos] = useState<Todo[]>([]) const [newTodo, setNewTodo] = useState<string>('') const removedTodo = useRef<string | null>(null) function resetInput() { setNewTodo('') } async function fetchTodos() { setTodos(await getTodos()) } useEffect(() => { fetchTodos() }, []) async function submitAddTodo() { await addTodo({ id: null, content: newTodo }) await fetchTodos() resetInput() } async function submitDeleteTodo(todo: Todo) { removedTodo.current = todo.id await deleteTodo(todo) await fetchTodos() removedTodo.current = null resetInput() } async function submitDeleteAllTodos() { await deleteAllTodos() await fetchTodos() resetInput() } return <></> } I omitted the JSX markup as that's not the point of today's study. I tried to handle all the waiting for API responses in a nice UX-friendly way, but I guess you'll be the judge of that. Although that made a bit of a mess in the component's state. The todo service functions look something like this: export interface Todo { id : string | null ; content : string ; } const BASE_URL = import . meta . env . DEV ? 'http://localhost:8080' : '/' const TODO_URL = ` ${ BASE_URL } /api/todos` export async function getTodos () : Promise < Todo [] > { const data = await fetchAPI ( TODO_URL ) return await data . json () } export async function addTodo ( newTodo : Todo ) : Promise < Response > { return fetchAPI ( TODO_URL , 'POST' , JSON . stringify ( newTodo )) } export function deleteTodo ( todo : Todo ) : Promise < Response > { return fetchAPI ( TODO_URL , 'DELETE' , JSON . stringify ( todo )) } export function deleteAllTodos () : Promise < Response > { return fetchAPI ( ` ${ TODO_URL } /all` , 'DELETE' ) } type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' async function fetchAPI ( url : string , method : HttpMethod = 'GET' , body? : string ) : Promise < Response > { return fetch ( url , { method , headers : { ...( method !== 'GET' && { 'Content-Type' : 'application/json' }) }, body }) } It's not a very clean or robust solution, but for the sake of this exercise, I tried to avoid too much duplication even while using the built-in fetch API. Also, the error handling and retrying of requests is completely missing. Now we'll try to improve upon this with the React Query library. React Query WIP","title":"Fetching data in React"},{"location":"frontend/react-query/#react-query-effective-data-fetching-in-react","text":"I've been developing in React for quite some time now. Usually when I needed to fetch some data, it was fine to create a useEffect hook, fetch it and then set it into a state using the useState hook. However, recently I've been wondering if there is a cleaner way, including error handling and retries. And of course there is. There is actually several. Here I'll try to learn more about the possibilities of data fetching in React","title":"React Query - Effective Data Fetching in React"},{"location":"frontend/react-query/#the-example-app","text":"I'll be trying the methods on an example todo app I prepared. The app looks something like this: The implementation is very trivial: function App() { const [todos, setTodos] = useState<Todo[]>([]) const [newTodo, setNewTodo] = useState<string>('') const removedTodo = useRef<string | null>(null) function resetInput() { setNewTodo('') } async function fetchTodos() { setTodos(await getTodos()) } useEffect(() => { fetchTodos() }, []) async function submitAddTodo() { await addTodo({ id: null, content: newTodo }) await fetchTodos() resetInput() } async function submitDeleteTodo(todo: Todo) { removedTodo.current = todo.id await deleteTodo(todo) await fetchTodos() removedTodo.current = null resetInput() } async function submitDeleteAllTodos() { await deleteAllTodos() await fetchTodos() resetInput() } return <></> } I omitted the JSX markup as that's not the point of today's study. I tried to handle all the waiting for API responses in a nice UX-friendly way, but I guess you'll be the judge of that. Although that made a bit of a mess in the component's state. The todo service functions look something like this: export interface Todo { id : string | null ; content : string ; } const BASE_URL = import . meta . env . DEV ? 'http://localhost:8080' : '/' const TODO_URL = ` ${ BASE_URL } /api/todos` export async function getTodos () : Promise < Todo [] > { const data = await fetchAPI ( TODO_URL ) return await data . json () } export async function addTodo ( newTodo : Todo ) : Promise < Response > { return fetchAPI ( TODO_URL , 'POST' , JSON . stringify ( newTodo )) } export function deleteTodo ( todo : Todo ) : Promise < Response > { return fetchAPI ( TODO_URL , 'DELETE' , JSON . stringify ( todo )) } export function deleteAllTodos () : Promise < Response > { return fetchAPI ( ` ${ TODO_URL } /all` , 'DELETE' ) } type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' async function fetchAPI ( url : string , method : HttpMethod = 'GET' , body? : string ) : Promise < Response > { return fetch ( url , { method , headers : { ...( method !== 'GET' && { 'Content-Type' : 'application/json' }) }, body }) } It's not a very clean or robust solution, but for the sake of this exercise, I tried to avoid too much duplication even while using the built-in fetch API. Also, the error handling and retrying of requests is completely missing. Now we'll try to improve upon this with the React Query library.","title":"The example app"},{"location":"frontend/react-query/#react-query","text":"WIP","title":"React Query"},{"location":"frontend/styled-components/","text":"Learning Styled Components with React I've never been a big fan of tinkering with CSS. It was always a struggle to try to achieve a pixel-perfect design of the app, and the process wasn't satisfying at all. In the backend, it always felt more satisfying to improve the existing architecture, or fix some issues in the logic. If I fixed some styling issues on the frontend, usually it led to an even more complicated CSS file. But that's probably mostly from lack of experience with it. But today I'll try to rewrite the basic Todo app's CSS into a cleaner Styled Components solution, while preserving the current design. The example app I'll be trying Styled Components with an example Todo app I prepared. The app looks something like this: My main goal is to not break the app when trying to fit in the Styled Components. Styled Components Let's start by installing the Styled Components library. I'll actually need two packages, as I'm using TypeScript: styled-components @types/styled-components Now let's see how I can improve the existing code with it. Here is the markup for the app now: function App() { // logic here return ( <div className=\"container\"> <div className=\"app-wrapper\"> <h1>TODO App</h1> <section className=\"add-todo-section\"> <label>New todo:</label> <input autoFocus autoComplete=\"off\" value={newTodo} onChange={e => setNewTodo(e.target.value)} onKeyUp={e => e.key === 'Enter' && submitAddTodo()} /> <button onClick={submitAddTodo}>\u2714</button> </section> {todos.length > 0 && ( <> <section className=\"todo-list-section\"> {todos.map(todo => ( <div className=\"todo-item-group\" key={todo.id}> <div> <input type=\"checkbox\" key={todo.id}/> <label>{todo.content}</label> </div> <button onClick={() => submitDeleteTodo(todo)}>\u2717</button> </div> ))} </section> <section className=\"global-actions-section\"> <button onClick={submitDeleteAllTodos}>Remove All</button> </section> </> )} </div> </div> ) } I'll start from the top. I'll try to refactor the container div into a styled component, and replace the div with it: const Container = styled . div ` display: flex; justify-content: center; align-items: center; ` Nothing broke, which is great! Let's continue with the rest of the CSS classes used in the markup. There is one CSS selector that I couldn't transform into a styled one: html , body { margin : 0 auto ; color : white ; background-color : #2a2a2a ; } The problem lies in not having any place to put this style. The React app is rendered within the <body> tag, so it's not like I can just wrap my app with <Body> styled components. Not even considering the <html> tag. The easier way (based on the library's docs) is to just put them in a <style> tag in the static index.html file itself, either manually or with code generation. I chose the first approach. Now the markup looks like this: function App() { // logic here return ( <Container> <Wrapper> <Heading>TODO App</Heading> <AddTodoSection> <label>New todo:</label> <Input autoFocus autoComplete=\"off\" value={newTodo} onChange={e => setNewTodo(e.target.value)} onKeyUp={e => e.key === 'Enter' && submitAddTodo()} /> <Button onClick={submitAddTodo}>\u2714</Button> </AddTodoSection> {todos.length > 0 && ( <> <TodoListSection> {todos.map(todo => ( <TodoItem key={todo.id}> <div> <input type=\"checkbox\" key={todo.id} /> <label>{todo.content}</label> </div> <Button onClick={() => submitDeleteTodo(todo)}>\u2717</Button> </TodoItem> ))} </TodoListSection> <GlobalActionsSection> <Button onClick={submitDeleteAllTodos}>Remove All</Button> </GlobalActionsSection> </> )} </Wrapper> </Container> ) } Conclusion Readability Personally, I think the readability of the app's markup improved. The length of the code is almost the same, but the fact that I don't have to intentionally skip over the class names among the other props actually helps a lot. Clarity of the code On the other hand, looking at the element, it might seem confusing which ones are just a styled HTML tag and which are actual subcomponents. E.g. what is <TodoItem> ? Is it a component with its own logic of rendering and controlling the todo item? Or is it just a <div> pretending to be something more complex than it is? If I looked at this code in a few days, I'd actually have to go to its definition to realize it's just styled. I'm not sure if there is a solution for this issue. It might help to create a naming convention for all styled components, like StyledButton instead of Button , but that would also increase verbosity. What I think would help a lot would be IDE hints, in the form of a different color for styled components and actual React function components. However, currently they are the same color in my IDE (Intellij IDEA). For now I might just accept the confusing nature of styled components appearing as real function components in the markup. The advantage of the overall readability outweighs this issue. But I'll still need to examine more features of this library to get a full view, and form a more complete opinion of it.","title":"Styled Components with React"},{"location":"frontend/styled-components/#learning-styled-components-with-react","text":"I've never been a big fan of tinkering with CSS. It was always a struggle to try to achieve a pixel-perfect design of the app, and the process wasn't satisfying at all. In the backend, it always felt more satisfying to improve the existing architecture, or fix some issues in the logic. If I fixed some styling issues on the frontend, usually it led to an even more complicated CSS file. But that's probably mostly from lack of experience with it. But today I'll try to rewrite the basic Todo app's CSS into a cleaner Styled Components solution, while preserving the current design.","title":"Learning Styled Components with React"},{"location":"frontend/styled-components/#the-example-app","text":"I'll be trying Styled Components with an example Todo app I prepared. The app looks something like this: My main goal is to not break the app when trying to fit in the Styled Components.","title":"The example app"},{"location":"frontend/styled-components/#styled-components","text":"Let's start by installing the Styled Components library. I'll actually need two packages, as I'm using TypeScript: styled-components @types/styled-components Now let's see how I can improve the existing code with it. Here is the markup for the app now: function App() { // logic here return ( <div className=\"container\"> <div className=\"app-wrapper\"> <h1>TODO App</h1> <section className=\"add-todo-section\"> <label>New todo:</label> <input autoFocus autoComplete=\"off\" value={newTodo} onChange={e => setNewTodo(e.target.value)} onKeyUp={e => e.key === 'Enter' && submitAddTodo()} /> <button onClick={submitAddTodo}>\u2714</button> </section> {todos.length > 0 && ( <> <section className=\"todo-list-section\"> {todos.map(todo => ( <div className=\"todo-item-group\" key={todo.id}> <div> <input type=\"checkbox\" key={todo.id}/> <label>{todo.content}</label> </div> <button onClick={() => submitDeleteTodo(todo)}>\u2717</button> </div> ))} </section> <section className=\"global-actions-section\"> <button onClick={submitDeleteAllTodos}>Remove All</button> </section> </> )} </div> </div> ) } I'll start from the top. I'll try to refactor the container div into a styled component, and replace the div with it: const Container = styled . div ` display: flex; justify-content: center; align-items: center; ` Nothing broke, which is great! Let's continue with the rest of the CSS classes used in the markup. There is one CSS selector that I couldn't transform into a styled one: html , body { margin : 0 auto ; color : white ; background-color : #2a2a2a ; } The problem lies in not having any place to put this style. The React app is rendered within the <body> tag, so it's not like I can just wrap my app with <Body> styled components. Not even considering the <html> tag. The easier way (based on the library's docs) is to just put them in a <style> tag in the static index.html file itself, either manually or with code generation. I chose the first approach. Now the markup looks like this: function App() { // logic here return ( <Container> <Wrapper> <Heading>TODO App</Heading> <AddTodoSection> <label>New todo:</label> <Input autoFocus autoComplete=\"off\" value={newTodo} onChange={e => setNewTodo(e.target.value)} onKeyUp={e => e.key === 'Enter' && submitAddTodo()} /> <Button onClick={submitAddTodo}>\u2714</Button> </AddTodoSection> {todos.length > 0 && ( <> <TodoListSection> {todos.map(todo => ( <TodoItem key={todo.id}> <div> <input type=\"checkbox\" key={todo.id} /> <label>{todo.content}</label> </div> <Button onClick={() => submitDeleteTodo(todo)}>\u2717</Button> </TodoItem> ))} </TodoListSection> <GlobalActionsSection> <Button onClick={submitDeleteAllTodos}>Remove All</Button> </GlobalActionsSection> </> )} </Wrapper> </Container> ) }","title":"Styled Components"},{"location":"frontend/styled-components/#conclusion","text":"","title":"Conclusion"},{"location":"frontend/styled-components/#readability","text":"Personally, I think the readability of the app's markup improved. The length of the code is almost the same, but the fact that I don't have to intentionally skip over the class names among the other props actually helps a lot.","title":"Readability"},{"location":"frontend/styled-components/#clarity-of-the-code","text":"On the other hand, looking at the element, it might seem confusing which ones are just a styled HTML tag and which are actual subcomponents. E.g. what is <TodoItem> ? Is it a component with its own logic of rendering and controlling the todo item? Or is it just a <div> pretending to be something more complex than it is? If I looked at this code in a few days, I'd actually have to go to its definition to realize it's just styled. I'm not sure if there is a solution for this issue. It might help to create a naming convention for all styled components, like StyledButton instead of Button , but that would also increase verbosity. What I think would help a lot would be IDE hints, in the form of a different color for styled components and actual React function components. However, currently they are the same color in my IDE (Intellij IDEA). For now I might just accept the confusing nature of styled components appearing as real function components in the markup. The advantage of the overall readability outweighs this issue. But I'll still need to examine more features of this library to get a full view, and form a more complete opinion of it.","title":"Clarity of the code"}]}